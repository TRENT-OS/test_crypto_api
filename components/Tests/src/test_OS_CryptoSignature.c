/**
 * Copyright (C) 2019-2024, HENSOLDT Cyber GmbH
 * 
 * SPDX-License-Identifier: GPL-2.0-or-later
 *
 * For commercial licensing, contact: info.cyber@hensoldt.net
 */

#include "OS_Crypto.h"

#include "SharedKeys.h"
#include "ObjectLocation.h"

#include "lib_macros/Test.h"

#include <string.h>

// -----------------------------------------------------------------------------

#define MAX_VECTOR_SIZE 2048
typedef struct
{
    size_t len;
    uint8_t bytes[MAX_VECTOR_SIZE];
} ByteVector;

typedef struct
{
    ByteVector sig;
    ByteVector hash;
    int hashType;
    OS_CryptoKey_Data_t pubKey;
    OS_CryptoKey_Data_t prvKey;
} TestVector;

typedef struct
{
    OS_CryptoDigest_Alg_t hashType;
    size_t keyBits;
    size_t hashBytes;
} RndTestParams;

// -----------------------------------------------------------------------------

#define NUM_PKCS1_V15_RND_TESTS 5
RndTestParams pkcs1V15RndParams[NUM_PKCS1_V15_RND_TESTS] =
{
    {
        .hashType = OS_CryptoDigest_ALG_NONE,
        .keyBits = 384,
        .hashBytes = 16
    },
    {
        .hashType = OS_CryptoDigest_ALG_NONE,
        .keyBits = 512,
        .hashBytes = 24
    },
    {
        .hashType = OS_CryptoDigest_ALG_NONE,
        .keyBits = 1024,
        .hashBytes = 32
    },
    {
        .hashType = OS_CryptoDigest_ALG_MD5,
        .keyBits = 512,
        .hashBytes = 16
    },
    {
        .hashType = OS_CryptoDigest_ALG_SHA256,
        .keyBits = 512,
        .hashBytes = 32
    },
};

#define NUM_PKCS1_V15_VECTORS 6
static TestVector pkcs1V15Vectors[NUM_PKCS1_V15_VECTORS] =
{
    {
        .sig = {
            .bytes = {
                0x31, 0x85, 0x7b, 0xf8, 0x14, 0x7d, 0x17, 0x99, 0xbe, 0x5c, 0xef, 0x4e, 0xd5, 0xad, 0xf4, 0x30,
                0xb2, 0x0f, 0x41, 0x18, 0x91, 0xe4, 0x8b, 0x2f, 0x4a, 0xb0, 0x33, 0xca, 0x09, 0xe4, 0x6e, 0xc7,
                0x5f, 0x63, 0xc5, 0x81, 0xd2, 0x70, 0x87, 0x25, 0x3d, 0xe1, 0xd9, 0x4a, 0xfc, 0xb7, 0x5d, 0x98,
                0xbd, 0x44,
            },
            .len = 50
        },
        .hash = {
            .bytes = {
                0x1b, 0x4d, 0x2b, 0x0e, 0x98, 0xae, 0x22, 0x3b, 0x0b, 0xa8, 0x72, 0x3f, 0xf5, 0x84, 0x5b, 0x97,
            },
            .len = 16
        },
        .hashType = OS_CryptoDigest_ALG_MD5,
        .pubKey = {
            .type = OS_CryptoKey_TYPE_RSA_PUB,
            .attribs.keepLocal = true,
            .data.rsa.pub = {
                .nBytes = {
                    0xbf, 0x29, 0x65, 0x80, 0x0e, 0xb3, 0x82, 0xdc, 0x98, 0x24, 0x0e, 0xfb, 0xa9, 0xfd, 0x5b, 0xa0,
                    0xf3, 0x7f, 0x9a, 0x4f, 0xf6, 0xa1, 0x93, 0xb0, 0xeb, 0x80, 0x20, 0x66, 0x23, 0x75, 0x49, 0xdd,
                    0x3c, 0x11, 0xca, 0xba, 0xe7, 0x50, 0x8e, 0xa3, 0x03, 0x63, 0xe3, 0xb0, 0x40, 0x21, 0x24, 0x34,
                    0x5b, 0x6d,
                },
                .nLen = 50,
                .eBytes = {

                    0x01, 0x00, 0x01,
                },
                .eLen = 3
            }
        },
        .prvKey = {
            .type = OS_CryptoKey_TYPE_RSA_PRV,
            .attribs.keepLocal = true,
            .data.rsa.prv = {
                .dBytes = {
                    0x15, 0xd1, 0x0c, 0x27, 0xf6, 0xc5, 0x8e, 0xf8, 0x4d, 0x16, 0xc4, 0x6c, 0xfd, 0x64, 0x10, 0x6a,
                    0x88, 0x8f, 0xb6, 0x15, 0x4d, 0x30, 0xf8, 0x91, 0x96, 0xc3, 0xfb, 0x82, 0xac, 0x14, 0x9e, 0x1b,
                    0x7c, 0xe2, 0x9d, 0x55, 0x91, 0xfd, 0x8a, 0x70, 0x18, 0x4a, 0x48, 0x1c, 0x86, 0x74, 0xae, 0x3c,
                    0x66, 0xc3,
                },
                .dLen = 50,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3,
                .pBytes = {
                    0xfe, 0xc5, 0x85, 0x04, 0x18, 0xc5, 0x4c, 0x78, 0x1e, 0x71, 0xdb, 0x59, 0xf7, 0x8c, 0xbc, 0xa4,
                    0x0b, 0xe5, 0xf1, 0xb6, 0x70, 0x3e, 0xaa, 0xaa, 0xbb,
                },
                .pLen = 25,
                .qBytes = {
                    0xc0, 0x15, 0x5b, 0xfa, 0x0f, 0xb0, 0x6c, 0x73, 0x72, 0x07, 0xcc, 0xf0, 0x4f, 0x98, 0xf4, 0xa3,
                    0x22, 0x60, 0xcd, 0xb2, 0xb4, 0x73, 0x1d, 0x53, 0xf7,
                },
                .qLen = 25
            }
        }
    },
    {
        .sig = {
            .bytes = {
                0xad, 0xe3, 0xdb, 0x92, 0xfb, 0x0c, 0x79, 0x28, 0xf7, 0xc7, 0xfb, 0x1b, 0x06, 0x78, 0x19, 0x25,
                0x4d, 0x63, 0xef, 0xdd, 0xac, 0x57, 0xd8, 0x4a, 0xfa, 0x02, 0x0f, 0x18, 0xd2, 0x0d, 0x67, 0x89,
                0xf0, 0x79, 0x46, 0x56, 0x34, 0x83, 0xf2, 0xf9, 0x66, 0x68, 0xec, 0xf2, 0xb1, 0x14, 0x2b, 0x2f,
                0x21, 0x35,
            },
            .len = 50
        },
        .hash = {
            .bytes = {
                0x19, 0xfe, 0xfa, 0xae, 0x1d, 0xa1, 0xfa, 0xa3, 0xdb, 0x7c, 0x94, 0xa2, 0x60, 0xa6, 0x7c, 0x34,
            },
            .len = 16
        },
        .hashType = OS_CryptoDigest_ALG_MD5,
        .pubKey = {
            .type = OS_CryptoKey_TYPE_RSA_PUB,
            .attribs.keepLocal = true,
            .data.rsa.pub = {
                .nBytes = {
                    0xbd, 0x9d, 0xba, 0x0e, 0x9a, 0x89, 0x0e, 0x20, 0x3b, 0x00, 0xab, 0x46, 0xa2, 0x41, 0xf1, 0x33,
                    0x21, 0x7a, 0x4c, 0x2a, 0x93, 0xc0, 0xe9, 0xb8, 0xd3, 0xd2, 0xbb, 0x7f, 0x92, 0xb5, 0x73, 0xd6,
                    0x1e, 0xbb, 0x73, 0x01, 0x65, 0xe4, 0x99, 0xf1, 0x48, 0xaf, 0xe2, 0xed, 0xc8, 0x8f, 0x38, 0xbe,
                    0x30, 0x4f,
                },
                .nLen = 50,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3
            }
        },
        .prvKey = {
            .type = OS_CryptoKey_TYPE_RSA_PRV,
            .attribs.keepLocal = true,
            .data.rsa.prv = {
                .dBytes = {
                    0x1e, 0x9f, 0xb1, 0x33, 0x77, 0x98, 0xe8, 0x0b, 0xa3, 0x8b, 0xdd, 0x9d, 0xa8, 0x49, 0xff, 0x23,
                    0x13, 0x66, 0x95, 0x93, 0x90, 0xce, 0x68, 0xd0, 0xfd, 0x39, 0xcd, 0xb4, 0x70, 0x9b, 0x6a, 0x6f,
                    0x00, 0x85, 0x9a, 0xfe, 0xc3, 0xd2, 0x14, 0xe6, 0x8c, 0xca, 0x25, 0xb6, 0x04, 0x35, 0x06, 0xb0,
                    0x85, 0x95,
                },
                .dLen = 50,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3,
                .pBytes = {
                    0xe1, 0x65, 0x85, 0x05, 0x54, 0xdf, 0x7d, 0x0b, 0x46, 0x05, 0x1d, 0x89, 0xcb, 0x86, 0x18, 0x6a,
                    0x54, 0xad, 0x3c, 0x2e, 0x55, 0x4a, 0xed, 0x08, 0xb3,
                },
                .pLen = 25,
                .qBytes = {
                    0xd7, 0x5c, 0x86, 0xfe, 0x9e, 0xfd, 0xc4, 0x16, 0xe3, 0xfc, 0x06, 0x29, 0x10, 0x00, 0x97, 0x76,
                    0xd5, 0x88, 0x30, 0x76, 0x2c, 0xf1, 0x84, 0x2f, 0xf5,
                },
                .qLen = 25
            }
        }
    },
    {
        .sig = {
            .bytes = {
                0x9f, 0x35, 0x26, 0x24, 0xc4, 0x2e, 0xda, 0x55, 0x16, 0xbe, 0x44, 0xd5, 0x62, 0xf3, 0x27, 0xcf,
                0x66, 0x10, 0xb1, 0x49, 0xc2, 0x58, 0xef, 0xb1, 0xaa, 0x10, 0x30, 0x63, 0x7f, 0x0f, 0xfe, 0xab,
                0x5c, 0x64, 0x53, 0x10, 0xbe, 0xbc, 0x1a, 0xdd, 0xe7, 0xbc, 0x2e, 0xa7, 0xf0, 0xe0, 0x80, 0x7d,
                0xb2, 0xf9,
            },
            .len = 50
        },
        .hash = {
            .bytes = {
                0x1b, 0x4d, 0x2b, 0x0e, 0x98, 0xae, 0x22, 0x3b, 0x0b, 0xa8, 0x72, 0x3f, 0xf5, 0x84, 0x5b, 0x97,
                0x04, 0xe1, 0x41, 0xf2,
            },
            .len = 20
        },
        .hashType = OS_CryptoDigest_ALG_NONE,
        .pubKey = {
            .type = OS_CryptoKey_TYPE_RSA_PUB,
            .attribs.keepLocal = true,
            .data.rsa.pub = {
                .nBytes = {
                    0xbf, 0x29, 0x65, 0x80, 0x0e, 0xb3, 0x82, 0xdc, 0x98, 0x24, 0x0e, 0xfb, 0xa9, 0xfd, 0x5b, 0xa0,
                    0xf3, 0x7f, 0x9a, 0x4f, 0xf6, 0xa1, 0x93, 0xb0, 0xeb, 0x80, 0x20, 0x66, 0x23, 0x75, 0x49, 0xdd,
                    0x3c, 0x11, 0xca, 0xba, 0xe7, 0x50, 0x8e, 0xa3, 0x03, 0x63, 0xe3, 0xb0, 0x40, 0x21, 0x24, 0x34,
                    0x5b, 0x6d,
                },
                .nLen = 50,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3
            }
        },
        .prvKey = {
            .type = OS_CryptoKey_TYPE_RSA_PRV,
            .attribs.keepLocal = true,
            .data.rsa.prv = {
                .dBytes = {
                    0x15, 0xd1, 0x0c, 0x27, 0xf6, 0xc5, 0x8e, 0xf8, 0x4d, 0x16, 0xc4, 0x6c, 0xfd, 0x64, 0x10, 0x6a,
                    0x88, 0x8f, 0xb6, 0x15, 0x4d, 0x30, 0xf8, 0x91, 0x96, 0xc3, 0xfb, 0x82, 0xac, 0x14, 0x9e, 0x1b,
                    0x7c, 0xe2, 0x9d, 0x55, 0x91, 0xfd, 0x8a, 0x70, 0x18, 0x4a, 0x48, 0x1c, 0x86, 0x74, 0xae, 0x3c,
                    0x66, 0xc3,
                },
                .dLen = 50,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3,
                .pBytes = {
                    0xfe, 0xc5, 0x85, 0x04, 0x18, 0xc5, 0x4c, 0x78, 0x1e, 0x71, 0xdb, 0x59, 0xf7, 0x8c, 0xbc, 0xa4,
                    0x0b, 0xe5, 0xf1, 0xb6, 0x70, 0x3e, 0xaa, 0xaa, 0xbb,
                },
                .pLen = 25,
                .qBytes = {
                    0xc0, 0x15, 0x5b, 0xfa, 0x0f, 0xb0, 0x6c, 0x73, 0x72, 0x07, 0xcc, 0xf0, 0x4f, 0x98, 0xf4, 0xa3,
                    0x22, 0x60, 0xcd, 0xb2, 0xb4, 0x73, 0x1d, 0x53, 0xf7,
                },
                .qLen = 25
            }
        }
    },
    {
        .sig = {
            .bytes = {
                0x86, 0x93, 0x29, 0x42, 0x7a, 0x9f, 0x3e, 0xd5, 0xa8, 0x8b, 0x16, 0xb5, 0x3b, 0x15, 0xed, 0xbe,
                0x1f, 0x74, 0x8c, 0x41, 0xb9, 0x31, 0xdc, 0xb1, 0x1d, 0xd1, 0x9e, 0x35, 0xf0, 0x18, 0x6f, 0xee,
                0xde, 0x87, 0x1b, 0x0f, 0xdb, 0xd3, 0x04, 0xfd, 0xac, 0x96, 0x98, 0xcd, 0x47, 0xec, 0xa8, 0x57,
                0x5b, 0xe1,
            },
            .len = 50
        },
        .hash = {
            .bytes = {
                0x4f, 0x2c, 0xd7, 0x80, 0x38, 0x3c, 0x48, 0x10, 0xa6, 0x3e, 0x72, 0x1e, 0xe2, 0xfb, 0xcd, 0x0b,
                0x67, 0x97, 0x85, 0x19,
            },
            .len = 20
        },
        .hashType = OS_CryptoDigest_ALG_NONE,
        .pubKey = {
            .type = OS_CryptoKey_TYPE_RSA_PUB,
            .attribs.keepLocal = true,
            .data.rsa.pub = {
                .nBytes = {
                    0xa1, 0xc0, 0xfc, 0x4d, 0xaf, 0xef, 0x81, 0x07, 0xd4, 0x3a, 0x43, 0x49, 0x89, 0x54, 0x07, 0x28,
                    0xf3, 0x15, 0x1f, 0x2c, 0xe1, 0x09, 0xb7, 0x78, 0xe5, 0x30, 0xdb, 0x42, 0x8b, 0xeb, 0xee, 0xf3,
                    0xd3, 0x63, 0x92, 0xd3, 0x42, 0x24, 0x2c, 0x99, 0xd2, 0xce, 0x3e, 0xd0, 0x04, 0x21, 0xc0, 0x18,
                    0x5b, 0x27,
                },
                .nLen = 50,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3
            }
        },
        .prvKey = {
            .type = OS_CryptoKey_TYPE_RSA_PRV,
            .attribs.keepLocal = true,
            .data.rsa.prv = {
                .dBytes = {
                    0x20, 0x03, 0xee, 0x0c, 0x44, 0x5b, 0xdf, 0xca, 0x98, 0x67, 0x75, 0xc4, 0xfa, 0xd0, 0xee, 0x5f,
                    0xdd, 0x09, 0x1b, 0xb4, 0x0a, 0xd0, 0x9d, 0x07, 0x68, 0xe8, 0xb0, 0x43, 0x0a, 0xff, 0x15, 0x04,
                    0xdf, 0xa2, 0xbb, 0x6f, 0x39, 0x67, 0x48, 0x93, 0x4b, 0xc9, 0x57, 0x0f, 0x39, 0xcc, 0x6a, 0xbd,
                    0xfd, 0x31,
                },
                .dLen = 50,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3,
                .pBytes = {
                    0xe1, 0xa0, 0xac, 0xe7, 0xdf, 0xf5, 0xc6, 0x1e, 0x63, 0xda, 0xf8, 0x34, 0xd9, 0xaa, 0xc3, 0x52,
                    0x65, 0xcd, 0x0b, 0xb2, 0x40, 0x93, 0xa9, 0x60, 0xf1,
                },
                .pLen = 25,
                .qBytes = {
                    0xb7, 0x87, 0x29, 0xf2, 0xd4, 0x26, 0xa6, 0x72, 0x3b, 0x3a, 0xbb, 0xa5, 0x5d, 0x05, 0x02, 0x42,
                    0x12, 0x0b, 0x8b, 0x90, 0x29, 0x88, 0x82, 0xfd, 0x97,
                },
                .qLen = 25
            }
        }
    },
    {
        .sig = {
            .bytes = {
                0x79, 0xf5, 0x6c, 0xa2, 0x55, 0x5b, 0x20, 0x5c, 0xd2, 0x36, 0x3a, 0x7f, 0x82, 0xd5, 0x6e, 0xcd,
                0x98, 0x8d, 0xc4, 0xb8, 0x15, 0xb0, 0x38, 0x63, 0x1f, 0x5b, 0xd9, 0xfb, 0xee, 0x96, 0xb2, 0x8e,
                0x0e, 0xd8, 0x94, 0xa3, 0xeb, 0x9d, 0x9e, 0xc4, 0xca, 0xeb, 0x38, 0x28, 0x95, 0x19, 0x59, 0x20,
                0x83, 0x47, 0x2b, 0xbc, 0xaf, 0xc9, 0x19, 0x7b, 0x78, 0x4d, 0xdd, 0x4b, 0xe7, 0xdc, 0x79, 0x92,
                0x00, 0xe0, 0x5a, 0xec, 0xf3, 0x8d, 0xda, 0x79, 0x1b, 0x13, 0xcc, 0x00, 0xaa, 0xbc, 0xd1, 0x39,
                0xae, 0xc6, 0x2c, 0x3e, 0x22, 0x62, 0xbc, 0x2c, 0x06, 0xfa, 0x05, 0x36, 0xe8, 0x88, 0x3c, 0xa7,
                0x5b, 0x28, 0xf2, 0x48, 0xe7, 0xeb, 0x48, 0xcd, 0x57, 0x54, 0xd2, 0xb8, 0xe2, 0x8c, 0xa9, 0xac,
                0x89, 0x8e, 0x4e, 0x17, 0x74, 0x89, 0xfb, 0x47, 0x59, 0x19, 0xbe, 0x12, 0xc2, 0x4a, 0x0e, 0x0f,
            },
            .len = 128
        },
        .hash = {
            .bytes = {
                0xae, 0x50, 0xb0, 0x9b, 0x3b, 0x95, 0xe3, 0xb2, 0xff, 0x4b, 0x6e, 0x89, 0x8c, 0xe0, 0xd1, 0xed,
                0x76, 0xa4, 0x14, 0x62, 0x20, 0x21, 0x1d, 0xcd, 0xf2, 0x38, 0x2b, 0xd7, 0xc0, 0xa5, 0x3b, 0x06,
            },
            .len = 32
        },
        .hashType = OS_CryptoDigest_ALG_SHA256,
        .pubKey = {
            .type = OS_CryptoKey_TYPE_RSA_PUB,
            .attribs.keepLocal = true,
            .data.rsa.pub = {
                .nBytes = {
                    0xb0, 0x66, 0x33, 0x2c, 0xc3, 0x92, 0x61, 0x1b, 0x67, 0x20, 0xd4, 0xac, 0x3e, 0xda, 0x64, 0x56,
                    0x20, 0xb8, 0xd2, 0xbb, 0x07, 0xdd, 0x61, 0x89, 0xd8, 0x3a, 0x7c, 0x45, 0xda, 0x2b, 0xc7, 0x22,
                    0xf2, 0xd0, 0x44, 0x4e, 0x95, 0x23, 0x04, 0xf2, 0x5a, 0x56, 0x97, 0x71, 0x65, 0x69, 0x7c, 0x51,
                    0x76, 0x44, 0xeb, 0xcf, 0x62, 0x68, 0x0a, 0xe6, 0x51, 0xe2, 0xb4, 0xa8, 0x35, 0x70, 0xfc, 0x12,
                    0xbc, 0xf3, 0x63, 0xa3, 0x96, 0x3d, 0x18, 0x57, 0xff, 0x07, 0xca, 0x89, 0x8e, 0x65, 0xec, 0x25,
                    0x6f, 0x75, 0x73, 0xc4, 0xbd, 0xce, 0x29, 0xee, 0x3a, 0x31, 0x03, 0x42, 0xc4, 0x8d, 0x94, 0x3c,
                    0x0f, 0x92, 0x53, 0x76, 0x26, 0x4a, 0x31, 0x79, 0x7d, 0x07, 0x29, 0xab, 0x57, 0x14, 0xd6, 0x54,
                    0xe5, 0xa9, 0x3f, 0x4d, 0x35, 0x52, 0xed, 0x85, 0xa5, 0x18, 0xc3, 0xb1, 0x65, 0xed, 0x61, 0x69,
                },
                .nLen = 128,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3
            }
        },
        .prvKey = {
            .type = OS_CryptoKey_TYPE_RSA_PRV,
            .attribs.keepLocal = true,
            .data.rsa.prv = {
                .dBytes = {
                    0x05, 0xba, 0x95, 0x4e, 0xb9, 0x72, 0xf3, 0x7b, 0xe8, 0xc3, 0x6d, 0xc7, 0x6d, 0x4a, 0xce, 0xf2,
                    0x3c, 0x21, 0xa7, 0x2d, 0xb8, 0xa6, 0xea, 0xda, 0xc7, 0x9e, 0xb8, 0xa2, 0xaa, 0x75, 0x51, 0xae,
                    0xe9, 0x22, 0x09, 0xec, 0x8a, 0x6b, 0xe6, 0xd1, 0x24, 0x78, 0x1b, 0xa1, 0x82, 0x13, 0x65, 0x07,
                    0x49, 0x41, 0xc4, 0xed, 0xc9, 0x35, 0x4b, 0x50, 0xa9, 0x17, 0xfa, 0xd9, 0x86, 0xa8, 0xca, 0xca,
                    0xec, 0x30, 0xa6, 0x28, 0xc4, 0xa2, 0xd1, 0xd4, 0xb8, 0x33, 0xc8, 0x1e, 0x19, 0x46, 0x64, 0x86,
                    0x57, 0x81, 0x87, 0x02, 0xdb, 0x87, 0xa3, 0xea, 0x07, 0x12, 0x80, 0x4f, 0x39, 0xda, 0x43, 0x60,
                    0x4e, 0x55, 0x8a, 0xc7, 0xbb, 0x93, 0x7d, 0xb2, 0x4a, 0x06, 0x66, 0xa7, 0xc4, 0xb0, 0x49, 0x8e,
                    0x06, 0xdc, 0x4f, 0xcf, 0x7b, 0x4a, 0x40, 0x14, 0xeb, 0x3d, 0xf9, 0x76, 0x77, 0x6c, 0x49, 0xcd,
                },
                .dLen = 128,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3,
                .pBytes = {
                    0xda, 0x5d, 0xda, 0xa6, 0xed, 0x5c, 0x69, 0x5f, 0x9d, 0x71, 0x96, 0x1a, 0xba, 0xf7, 0x4d, 0x62,
                    0xd0, 0xae, 0x3b, 0x08, 0xff, 0x32, 0x54, 0xee, 0x44, 0x1e, 0x74, 0xe0, 0x98, 0x8a, 0xcf, 0x5c,
                    0x58, 0x6d, 0x53, 0x14, 0x72, 0x96, 0x51, 0xa6, 0x90, 0xfc, 0x16, 0x4b, 0x59, 0x82, 0xe2, 0xd4,
                    0xb9, 0x6a, 0x9c, 0xb5, 0x47, 0x70, 0xf3, 0xbf, 0x10, 0x94, 0xe1, 0x5f, 0x89, 0x62, 0x71, 0x45,
                },
                .pLen = 64,
                .qBytes = {
                    0xce, 0xcc, 0xc7, 0xcf, 0xca, 0x74, 0x5b, 0x97, 0xe7, 0xa5, 0x42, 0xd9, 0xb9, 0xa4, 0xc9, 0xfd,
                    0xe2, 0x14, 0x3a, 0x1e, 0xd1, 0x66, 0xfc, 0xa9, 0x3e, 0x34, 0x8c, 0x78, 0xc8, 0xda, 0x84, 0xd1,
                    0x65, 0xac, 0xcc, 0xfd, 0x7f, 0x8e, 0x3c, 0x1f, 0x7d, 0xef, 0xca, 0x89, 0x6a, 0x29, 0xe9, 0x85,
                    0x1d, 0x47, 0x90, 0xaf, 0xdf, 0x52, 0x42, 0x85, 0xe6, 0xf7, 0xce, 0x80, 0x4d, 0x5f, 0x47, 0xd5,
                },
                .qLen = 64
            }
        }
    },
    {
        .sig = {
            .bytes = {
                0xb4, 0x87, 0x1d, 0x44, 0x52, 0x7b, 0x89, 0x69, 0x71, 0x6b, 0x1f, 0x1f, 0x67, 0x6f, 0x60, 0xed,
                0x8a, 0xf6, 0xe6, 0xa1, 0xae, 0x89, 0xae, 0x56, 0xca, 0x7b, 0xa5, 0x90, 0x90, 0xca, 0xf6, 0x04,
                0xcb, 0xbd, 0xc3, 0xd9, 0x34, 0xde, 0x9e, 0xdd, 0xb0, 0x69, 0x36, 0x52, 0x92, 0x30, 0x3f, 0x51,
                0x3a, 0x27, 0xb6, 0x6c, 0x19, 0x82, 0xb9, 0xf1, 0xd3, 0x4d, 0x85, 0x6d, 0x0c, 0x55, 0x47, 0xbd,
                0x77, 0x1d, 0xc6, 0x1a, 0x3a, 0xd9, 0x19, 0x47, 0x9a, 0x93, 0x29, 0xd1, 0x12, 0xf2, 0x0a, 0xf6,
                0x2d, 0x3d, 0x66, 0x91, 0x86, 0x38, 0x75, 0xa3, 0x18, 0x27, 0x26, 0xa3, 0x47, 0x31, 0xff, 0x06,
                0x10, 0xaa, 0x17, 0x14, 0xc5, 0x97, 0x17, 0xef, 0x80, 0x2f, 0xc3, 0x3a, 0x93, 0xc1, 0x4d, 0x0f,
                0x37, 0x4a, 0x3e, 0xd7, 0x18, 0x3d, 0xe9, 0x2c, 0x2a, 0xc7, 0xd6, 0xc8, 0x4d, 0x83, 0x2a, 0xbd,
            },
            .len = 128
        },
        .hash = {
            .bytes = {
                0xbd, 0xb6, 0x1c, 0xd0, 0x9f, 0x94, 0xdf, 0xe2, 0x4a, 0x83, 0x71, 0xc1, 0xa1, 0x15, 0x9b, 0xaa,
                0x01, 0x0a, 0xc2, 0xee, 0x42, 0x50, 0x72, 0x8a, 0x27, 0xfe, 0x53, 0x18, 0xfe, 0x30, 0x70, 0xc8,
            },
            .len = 32
        },
        .hashType = OS_CryptoDigest_ALG_SHA256,
        .pubKey = {
            .type = OS_CryptoKey_TYPE_RSA_PUB,
            .attribs.keepLocal = true,
            .data.rsa.pub = {
                .nBytes = {
                    0xd0, 0xf8, 0xd6, 0xe1, 0xf7, 0xfe, 0xab, 0x8f, 0xd2, 0x62, 0x86, 0x53, 0xc0, 0x0f, 0x07, 0x93,
                    0xee, 0x7f, 0xc3, 0x0c, 0x5f, 0x44, 0xe0, 0x05, 0x5b, 0xc9, 0x04, 0x30, 0xee, 0x77, 0xd6, 0xe5,
                    0x04, 0x71, 0xa3, 0x22, 0xdc, 0x4e, 0xaa, 0xdb, 0xa0, 0xad, 0xc0, 0xc2, 0x01, 0x37, 0xbf, 0xd4,
                    0xac, 0x9c, 0x7b, 0x22, 0xc6, 0xf5, 0xba, 0xd4, 0x0c, 0xd3, 0xb7, 0x28, 0x23, 0xff, 0x1c, 0x66,
                    0x34, 0x18, 0xbb, 0x55, 0xda, 0x00, 0x35, 0xa6, 0xd5, 0x11, 0x08, 0xee, 0x8a, 0xf7, 0x9d, 0x1b,
                    0x8b, 0xdc, 0x57, 0xd0, 0x0d, 0xd2, 0x20, 0x0f, 0x6b, 0xec, 0xfe, 0xe7, 0x8a, 0xf3, 0x03, 0xbb,
                    0xbb, 0xe3, 0xe8, 0xf5, 0x5f, 0x92, 0x39, 0x17, 0xd1, 0x84, 0x50, 0xbf, 0x7f, 0x61, 0xcb, 0x1b,
                    0xbe, 0x6e, 0xab, 0x68, 0x74, 0x9e, 0x43, 0xf5, 0xde, 0x0b, 0x83, 0xef, 0x26, 0x2b, 0xac, 0xaf,
                },
                .nLen = 128,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3
            }
        },
        .prvKey = {
            .type = OS_CryptoKey_TYPE_RSA_PRV,
            .attribs.keepLocal = true,
            .data.rsa.prv = {
                .dBytes = {
                    0x01, 0x04, 0xcd, 0x8b, 0x61, 0x79, 0xa0, 0xdd, 0x7d, 0x21, 0x94, 0xd5, 0x10, 0xb1, 0x22, 0x10,
                    0xd3, 0x0f, 0x55, 0x64, 0x98, 0x8c, 0x4d, 0xe9, 0x48, 0xc6, 0xc4, 0x99, 0xf6, 0x77, 0xa8, 0x19,
                    0x0a, 0xba, 0x01, 0x19, 0x18, 0xe8, 0xdb, 0x45, 0x61, 0xd5, 0xa7, 0x04, 0x6b, 0x1c, 0x19, 0xf7,
                    0xcf, 0xf5, 0x9d, 0x56, 0x10, 0x91, 0x3f, 0x1d, 0x6c, 0x88, 0x95, 0xb2, 0x80, 0xe6, 0x6b, 0xfd,
                    0x83, 0x4e, 0xe8, 0x0c, 0x24, 0xf9, 0x18, 0xb9, 0xdb, 0x74, 0x06, 0x58, 0x63, 0x3b, 0x0c, 0x0f,
                    0x01, 0x9c, 0xfd, 0x19, 0x36, 0xcf, 0xc4, 0x4b, 0xa1, 0xca, 0xfe, 0xcf, 0x23, 0xe2, 0x56, 0x45,
                    0x32, 0xd3, 0xad, 0xd3, 0x48, 0x27, 0xb7, 0x7a, 0xbd, 0xd9, 0x36, 0x5a, 0x1d, 0x8c, 0x69, 0xb6,
                    0xb6, 0xb5, 0x3c, 0xc4, 0x94, 0xfb, 0x74, 0x44, 0x32, 0x59, 0x65, 0xec, 0x02, 0xfe, 0xbf, 0x91,
                },
                .dLen = 128,
                .eBytes = {

                    0x01, 0x00, 0x01,
                },
                .eLen = 3,
                .pBytes = {
                    0xee, 0x74, 0xf9, 0xc5, 0x7d, 0xfe, 0xad, 0xa1, 0x04, 0xf7, 0x54, 0xa5, 0x71, 0x58, 0x58, 0xee,
                    0x7c, 0x0e, 0xad, 0x92, 0xe7, 0x9e, 0xce, 0x2e, 0x54, 0x83, 0x5c, 0xad, 0xa7, 0x82, 0x1c, 0x79,
                    0x4a, 0x76, 0xb5, 0xf6, 0x81, 0x5f, 0x73, 0x0a, 0x55, 0x41, 0xf0, 0x23, 0x22, 0x65, 0xcc, 0x05,
                    0xc8, 0x59, 0x06, 0x62, 0x43, 0x2c, 0x66, 0xec, 0x5f, 0x39, 0x97, 0x61, 0xb4, 0xfd, 0xe9, 0x91,
                },
                .pLen = 64,
                .qBytes = {
                    0xe0, 0x58, 0x8d, 0xd7, 0xa7, 0x87, 0xfb, 0x70, 0xa2, 0xec, 0x98, 0x4f, 0xd9, 0x93, 0x04, 0x08,
                    0x77, 0x91, 0xcd, 0x54, 0xdb, 0xb3, 0x08, 0xa5, 0x53, 0xce, 0x1b, 0xe8, 0x68, 0x11, 0x07, 0xae,
                    0x88, 0xc2, 0xcf, 0xab, 0xf4, 0x3b, 0xe1, 0x54, 0x22, 0x27, 0xc6, 0x82, 0x00, 0x6a, 0xc2, 0x7d,
                    0x62, 0xb1, 0x81, 0xe9, 0xf2, 0xeb, 0x0d, 0xca, 0xe7, 0xb5, 0x43, 0x28, 0xf3, 0x93, 0x12, 0x3f,
                },
                .qLen = 64
            }
        }
    }
};

// -----------------------------------------------------------------------------

#define NUM_PKCS1_V21_VECTORS 4
static TestVector pkcs1V21Vectors[NUM_PKCS1_V21_VECTORS] =
{
    {
        .sig = {
            .bytes = {
                0x58, 0xaa, 0x77, 0xac, 0xbc, 0x8e, 0x2d, 0x7c, 0x53, 0x39, 0x16, 0x87, 0x0a, 0x07, 0x29, 0x7d,
                0x2c, 0x40, 0x96, 0x91, 0x7e, 0xcd, 0x48, 0x88, 0x7d, 0x39, 0x80, 0x7e, 0x76, 0x7d, 0xab, 0x19,
                0x85, 0x26, 0xfb, 0x23, 0x9d, 0x59, 0x7c, 0x80, 0xce, 0xf7, 0xf1, 0xd6, 0xb4, 0xce, 0x56, 0xd8,
            },
            .len = 48
        },
        .hash = {
            .bytes = {
                0x14, 0x69, 0x6a, 0xf4, 0xf3, 0xb9, 0x6b, 0x92, 0x25, 0x94, 0x79, 0x85, 0x69, 0x25, 0x6f, 0x4e,
            },
            .len = 16
        },
        .hashType = OS_CryptoDigest_ALG_MD5,
        .pubKey = {
            .type = OS_CryptoKey_TYPE_RSA_PUB,
            .attribs.keepLocal = true,
            .data.rsa.pub = {
                .nBytes = {
                    0xbf, 0x54, 0x54, 0xf8, 0x2c, 0xa9, 0xfc, 0x2b, 0xb5, 0xaa, 0x87, 0x41, 0x43, 0x8a, 0xeb, 0x53,
                    0xec, 0x7d, 0x40, 0xb9, 0xee, 0x92, 0xcf, 0x91, 0x00, 0x02, 0xb4, 0x2e, 0x97, 0xdb, 0x36, 0xec,
                    0xaa, 0x92, 0x2c, 0xc5, 0xee, 0x45, 0x83, 0x13, 0x19, 0x00, 0x6e, 0x1c, 0x4f, 0x0a, 0x91, 0x3f,
                },
                .nLen = 48,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3
            }
        },
        .prvKey = {
            .type = OS_CryptoKey_TYPE_RSA_PRV,
            .attribs.keepLocal = true,
            .data.rsa.prv = {
                .dBytes = {
                    0x50, 0x45, 0x49, 0xd6, 0xcb, 0x2a, 0x4f, 0xf5, 0x68, 0xa4, 0xd0, 0x55, 0x25, 0xc8, 0xb9, 0x3d,
                    0x7f, 0x08, 0xf7, 0xa8, 0x6a, 0x3a, 0xe6, 0xe0, 0xe5, 0x5e, 0xcc, 0x14, 0x4c, 0xe4, 0x78, 0x67,
                    0xd6, 0xdb, 0x45, 0x7d, 0x4f, 0xe2, 0xec, 0xf1, 0x23, 0x56, 0x89, 0xf0, 0xc9, 0x27, 0x9d, 0x25,
                },
                .dLen = 48,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3,
                .pBytes = {
                    0xe7, 0x1b, 0xd5, 0xc3, 0x0f, 0x2a, 0x2e, 0x87, 0x53, 0x7f, 0xc2, 0xe6, 0x82, 0xf9, 0x55, 0xef,
                    0xc7, 0x01, 0x23, 0xd4, 0x88, 0x38, 0x8d, 0xbb,
                },
                .pLen = 24,
                .qBytes = {
                    0xd3, 0xef, 0xb2, 0x1d, 0x55, 0x98, 0xd6, 0x1d, 0x9b, 0xd4, 0x6c, 0xc8, 0x11, 0xbb, 0x5d, 0x82,
                    0xbb, 0x9d, 0x7d, 0x26, 0x8a, 0xa0, 0xd0, 0x4d,
                },
                .qLen = 24
            }
        }
    },
    {
        .sig = {
            .bytes = {
                0x2c, 0x8d, 0xac, 0x4b, 0xdb, 0x53, 0x65, 0x5c, 0xa3, 0x2b, 0xe4, 0x35, 0xa4, 0xc3, 0x71, 0xf4,
                0x71, 0x6e, 0x52, 0xf2, 0x1c, 0x11, 0xe8, 0x58, 0x2f, 0xce, 0xa6, 0x04, 0x8d, 0x13, 0x78, 0x91,
                0x01, 0xfd, 0x47, 0x73, 0x53, 0x39, 0xcb, 0x46, 0xcf, 0xde, 0xe8, 0xf7, 0xf4, 0xe2, 0xc7, 0x3d,
                0x7a, 0xdc, 0x77, 0xd6, 0xcb, 0x60, 0x69, 0x4f, 0xf0, 0xbc, 0xed, 0x8a, 0x0e, 0xb4, 0x4a, 0x14,
            },
            .len = 64
        },
        .hash = {
            .bytes = {
                0xd7, 0xe4, 0x97, 0x46, 0x8b, 0xcd, 0x83, 0x98, 0xb2, 0x7e, 0x17, 0xe5, 0x72, 0x01, 0x82, 0xa5,
            },
            .len = 16
        },
        .hashType = OS_CryptoDigest_ALG_MD5,
        .pubKey = {
            .type = OS_CryptoKey_TYPE_RSA_PUB,
            .attribs.keepLocal = true,
            .data.rsa.pub = {
                .nBytes = {
                    0xa7, 0x8a, 0xb6, 0x4a, 0x7e, 0x1d, 0xff, 0xbf, 0x6a, 0x32, 0xfc, 0xf7, 0x10, 0x18, 0x25, 0x5a,
                    0xc1, 0x93, 0x47, 0x00, 0x95, 0x7d, 0x80, 0x67, 0x9e, 0xa1, 0x79, 0xd3, 0xfb, 0x9a, 0x34, 0xc1,
                    0x4d, 0x8f, 0x13, 0x4f, 0x14, 0xfd, 0xa1, 0x47, 0x7b, 0x40, 0x0f, 0xf6, 0xfd, 0x0f, 0xaf, 0xd1,
                    0xe8, 0xad, 0x16, 0x56, 0x68, 0x01, 0x7c, 0x6d, 0xa3, 0x31, 0x28, 0x0f, 0xd2, 0xa7, 0xda, 0xa5,
                },
                .nLen = 64,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3
            }
        },
        .prvKey = {
            .type = OS_CryptoKey_TYPE_RSA_PRV,
            .attribs.keepLocal = true,
            .data.rsa.prv = {
                .dBytes = {
                    0x01, 0xf1, 0x45, 0xef, 0x73, 0x7f, 0xe0, 0x8a, 0x5f, 0xc3, 0xab, 0x3d, 0x7d, 0x66, 0x72, 0x44,
                    0x6c, 0xf0, 0x75, 0x5c, 0x73, 0x34, 0x95, 0xcb, 0xb3, 0x17, 0x4c, 0x84, 0xcc, 0x80, 0x26, 0x08,
                    0x14, 0xde, 0x96, 0x84, 0x74, 0x0e, 0xf9, 0x2d, 0xed, 0xd6, 0xb0, 0xa3, 0xd9, 0x79, 0xd4, 0xff,
                    0x14, 0x0c, 0x57, 0x7d, 0x25, 0x9b, 0x72, 0xa9, 0xd1, 0x0f, 0x0a, 0x57, 0x72, 0x76, 0x92, 0x21,
                },
                .dLen = 64,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3,
                .pBytes = {
                    0xeb, 0x37, 0x98, 0x3c, 0x51, 0xdd, 0x5e, 0x10, 0x79, 0x0a, 0xeb, 0x2e, 0x91, 0xdf, 0x01, 0xfc,
                    0x5b, 0x1c, 0x67, 0xd6, 0x93, 0x5d, 0xc9, 0x35, 0xdb, 0xe2, 0xe4, 0x59, 0x65, 0x73, 0x48, 0x91,
                },
                .pLen = 32,
                .qBytes = {
                    0xb6, 0x58, 0x5c, 0x74, 0xc7, 0x79, 0x77, 0x13, 0xa0, 0x59, 0x7b, 0x4d, 0x03, 0x22, 0x5e, 0x93,
                    0xab, 0xbe, 0xfe, 0xbe, 0xcd, 0x32, 0x03, 0x17, 0x14, 0x3a, 0x15, 0x47, 0x4f, 0x61, 0xda, 0xd5,
                },
                .qLen = 32
            }
        }
    },
    {
        .sig = {
            .bytes = {
                0x35, 0xe1, 0xa2, 0xc7, 0x25, 0x4c, 0xe6, 0xba, 0x24, 0xf6, 0x76, 0x23, 0xa8, 0x03, 0x54, 0xb1,
                0xee, 0x63, 0x7a, 0x70, 0xfb, 0x4c, 0xe5, 0x80, 0xee, 0xa6, 0x42, 0x74, 0xc6, 0x76, 0x22, 0x8a,
                0xf1, 0x1b, 0x0a, 0xe6, 0x49, 0x24, 0x5e, 0xd3, 0x27, 0xaa, 0xd7, 0x9c, 0x04, 0xe3, 0xe3, 0x5f,
                0x1a, 0xab, 0xab, 0x54, 0x91, 0x60, 0x3d, 0x9a, 0x71, 0x09, 0x3a, 0xc0, 0x0a, 0xea, 0x23, 0x3b,
                0x26, 0xf5, 0xe0, 0xc9, 0x05, 0x1b, 0x0b, 0xe7, 0x9d, 0xec, 0x1d, 0x89, 0xc9, 0xe5, 0x58, 0x60,
                0x7b, 0xe2, 0x91, 0x94, 0x25, 0x88, 0x11, 0x5e, 0xe0, 0x63, 0x83, 0x72, 0x58, 0x3b, 0xa3, 0x10,
                0xb6, 0x19, 0xe9, 0x2e, 0x64, 0xc3, 0x4b, 0x41, 0xe0, 0xee, 0xb1, 0xe4, 0xc6, 0x40, 0xc7, 0x5d,
                0x71, 0x8d, 0xcc, 0x19, 0x47, 0xea, 0x67, 0x35, 0x14, 0x9d, 0xe3, 0x3c, 0x57, 0x8d, 0xfc, 0x6d,
            },
            .len = 128
        },
        .hash = {
            .bytes = {
                0x12, 0xf7, 0x20, 0xc5, 0x33, 0x3d, 0xde, 0x4a, 0x1e, 0x37, 0xaa, 0x31, 0x8f, 0x6d, 0x50, 0x60,
            },
            .len = 16
        },
        .hashType = OS_CryptoDigest_ALG_MD5,
        .pubKey = {
            .type = OS_CryptoKey_TYPE_RSA_PUB,
            .attribs.keepLocal = true,
            .data.rsa.pub = {
                .nBytes = {
                    0xd9, 0x6f, 0xe4, 0xf1, 0xad, 0xff, 0xc3, 0x32, 0xc3, 0x9e, 0xde, 0xcc, 0xac, 0x5d, 0xae, 0x33,
                    0x1c, 0xf2, 0xb3, 0x28, 0x35, 0x11, 0xcd, 0xe3, 0xf4, 0x65, 0x19, 0x54, 0x6f, 0x94, 0x4c, 0x94,
                    0xb8, 0xa0, 0x04, 0x25, 0x30, 0x1c, 0xb1, 0xc1, 0xdb, 0x83, 0xc7, 0x93, 0xf1, 0x46, 0x03, 0x6a,
                    0x8d, 0x4f, 0x48, 0x2b, 0xb6, 0xb6, 0x09, 0xc2, 0x68, 0xf9, 0x76, 0x9d, 0x87, 0x9d, 0xa4, 0xcb,
                    0x03, 0x4e, 0x77, 0xf4, 0xe9, 0x32, 0xf7, 0xb6, 0xd8, 0x98, 0x4f, 0xf3, 0xaf, 0xb5, 0x17, 0x00,
                    0x80, 0xab, 0x59, 0x5f, 0x6a, 0x72, 0xfd, 0xc6, 0x03, 0x5c, 0x21, 0xea, 0x63, 0x68, 0xb7, 0xeb,
                    0x88, 0x59, 0x23, 0xd8, 0x50, 0x52, 0x9d, 0x31, 0xe2, 0xc1, 0x46, 0x35, 0xf2, 0xfa, 0x62, 0xc5,
                    0xb4, 0x60, 0x93, 0xc9, 0x7f, 0x6d, 0x86, 0x74, 0x83, 0x90, 0xca, 0x45, 0xc6, 0x58, 0x75, 0x89,
                },
                .nLen = 128,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3
            }
        },
        .prvKey = {
            .type = OS_CryptoKey_TYPE_RSA_PRV,
            .attribs.keepLocal = true,
            .data.rsa.prv = {
                .dBytes = {
                    0xe8, 0x5a, 0x29, 0xf6, 0x19, 0x06, 0x42, 0xe7, 0xc6, 0xaf, 0x76, 0x56, 0x0f, 0x78, 0x0c, 0x2e,
                    0xcc, 0x59, 0x22, 0x5b, 0xf1, 0xd5, 0xdf, 0x19, 0xcd, 0xda, 0x4b, 0xbf, 0x4d, 0xdf, 0xed, 0x92,
                    0xcd, 0xb8, 0x10, 0x00, 0x41, 0xf1, 0xc2, 0xa7, 0x7a, 0x84, 0xbe, 0xee, 0x1a, 0xf2, 0x25, 0xb4,
                    0x68, 0xb0, 0x01, 0x94, 0x83, 0x64, 0x90, 0x2a, 0x4c, 0x6e, 0x58, 0x67, 0x40, 0x35, 0xf7, 0x93,
                    0x22, 0x4b, 0xb2, 0x17, 0xa1, 0x41, 0xb0, 0x50, 0x8e, 0x37, 0xba, 0x0c, 0xe1, 0x50, 0x78, 0xe9,
                    0x4d, 0xe4, 0x1c, 0x70, 0x90, 0xc5, 0x5f, 0x4f, 0x67, 0x9a, 0xfd, 0x0e, 0xc1, 0x66, 0x36, 0x1b,
                    0xde, 0x5c, 0xe6, 0xe5, 0xee, 0x90, 0x41, 0x8c, 0xb6, 0x40, 0x99, 0x77, 0xdb, 0xf8, 0xe2, 0x84,
                    0xe6, 0x29, 0x17, 0xbd, 0x2d, 0x1a, 0x95, 0xa3, 0xc5, 0xa8, 0x20, 0x84, 0x6c, 0xe4, 0xbf,
                },
                .dLen = 127,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3,
                .pBytes = {
                    0xef, 0x5f, 0x0a, 0x5b, 0x93, 0x53, 0x0e, 0x99, 0xbd, 0x89, 0x0a, 0xd4, 0x2c, 0x97, 0xe6, 0x8a,
                    0x9b, 0x92, 0xd5, 0x4a, 0xe7, 0x94, 0xf4, 0x65, 0xa1, 0x12, 0xdc, 0xb1, 0xd3, 0x3b, 0xef, 0xa8,
                    0x15, 0xdc, 0x0b, 0x1f, 0x29, 0xea, 0x74, 0xf6, 0x69, 0xec, 0xe3, 0x80, 0x8f, 0x75, 0x82, 0x12,
                    0xc6, 0xa3, 0xc2, 0xbf, 0x66, 0x9c, 0x06, 0x30, 0xc2, 0xaa, 0x8c, 0x4b, 0x27, 0x07, 0xb9, 0xe3,
                },
                .pLen = 64,
                .qBytes = {
                    0xe8, 0x8a, 0xc7, 0x44, 0xb0, 0x46, 0x5e, 0x5e, 0x4e, 0xa6, 0x22, 0xf5, 0x13, 0x33, 0xb6, 0x01,
                    0xea, 0x24, 0x09, 0x36, 0x37, 0x33, 0xf2, 0x44, 0x98, 0x20, 0xc8, 0xb6, 0xa3, 0x09, 0x6b, 0x4f,
                    0x76, 0x55, 0x6f, 0x34, 0xb5, 0xa6, 0x3d, 0xe4, 0x24, 0x1d, 0x40, 0x8a, 0xba, 0x5c, 0xb6, 0x47,
                    0x83, 0xbb, 0xf2, 0xe5, 0xc5, 0x9e, 0x92, 0xc0, 0xaa, 0x4c, 0x79, 0x50, 0x83, 0xf1, 0x9e, 0xa3,
                },
                .qLen = 64
            }
        }
    },
    {
        .sig = {
            .bytes = {
                0x40, 0x44, 0xd5, 0x25, 0x65, 0x32, 0xf7, 0x57, 0x00, 0xb8, 0xa1, 0x5b, 0xeb, 0xc3, 0xd8, 0xef,
                0xf0, 0x54, 0xf2, 0x78, 0x0a, 0x02, 0x6f, 0x9a, 0xde, 0x7f, 0x5e, 0xf5, 0xff, 0x83, 0xc9, 0x9d,
                0x70, 0x90, 0xee, 0x4e, 0x4e, 0xd4, 0x9f, 0xe8, 0x99, 0xcf, 0x40, 0x14, 0xa1, 0x01, 0x70, 0x25,
                0xef, 0x5d, 0xc1, 0xf1, 0xcd, 0x3b, 0x1c, 0x32, 0x73, 0xdf, 0x19, 0xc4, 0xed, 0x95, 0x5f, 0x35,
            },
            .len = 64
        },
        .hash = {
            .bytes = {
                0x9e, 0xa3, 0x17, 0xea, 0x54, 0x82, 0x11, 0x61, 0xf1, 0x26, 0x6b, 0xfa, 0x1c, 0x13, 0xeb, 0x30,
                0xc5, 0x2e, 0x73, 0x30, 0x6c, 0x47, 0x46, 0xda, 0xac, 0x50, 0x80, 0x2c, 0x29, 0xbf, 0xf3, 0xe7,
            },
            .len = 32
        },
        .hashType = OS_CryptoDigest_ALG_SHA256,
        .pubKey = {
            .type = OS_CryptoKey_TYPE_RSA_PUB,
            .attribs.keepLocal = true,
            .data.rsa.pub = {
                .nBytes = {
                    0x98, 0x91, 0x18, 0x4b, 0x61, 0xd6, 0x6e, 0x2a, 0x76, 0x5e, 0xfe, 0x84, 0xce, 0x40, 0xe9, 0x4b,
                    0x80, 0x78, 0xdf, 0x93, 0xaa, 0xaa, 0xaa, 0x1d, 0x55, 0x28, 0xfa, 0xbb, 0xef, 0x8c, 0x67, 0xe5,
                    0x36, 0x77, 0x49, 0xb5, 0xa6, 0x6e, 0x92, 0x4e, 0x05, 0x87, 0x64, 0xd5, 0x27, 0xca, 0xb4, 0x71,
                    0x84, 0xdd, 0x8e, 0x8d, 0x13, 0x35, 0xd0, 0x19, 0x0d, 0x19, 0x12, 0xd8, 0x06, 0x3d, 0xb2, 0x81,
                },
                .nLen = 64,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3
            }
        },
        .prvKey = {
            .type = OS_CryptoKey_TYPE_RSA_PRV,
            .attribs.keepLocal = true,
            .data.rsa.prv = {
                .dBytes = {
                    0x25, 0xb9, 0x72, 0xe5, 0x68, 0xda, 0xc9, 0xc0, 0xcc, 0x26, 0x2f, 0x0f, 0x0d, 0xa4, 0xf5, 0x4a,
                    0xcb, 0x08, 0x98, 0x57, 0xfe, 0x12, 0x57, 0x20, 0x0b, 0xa7, 0xa7, 0x60, 0x03, 0x1a, 0x97, 0xb1,
                    0xae, 0xa5, 0x96, 0xb5, 0x1f, 0xdb, 0x13, 0x97, 0xf3, 0x89, 0xba, 0x9b, 0x89, 0x24, 0x90, 0x1f,
                    0x80, 0x6f, 0xe4, 0xfa, 0xc4, 0x0e, 0xf8, 0x57, 0x82, 0x6a, 0x9e, 0x98, 0x92, 0xe6, 0x3b, 0x75,
                },
                .dLen = 64,
                .eBytes = {
                    0x01, 0x00, 0x01,
                },
                .eLen = 3,
                .pBytes = {
                    0xd4, 0xe7, 0x33, 0x77, 0x71, 0x14, 0xaf, 0x02, 0x88, 0x80, 0x59, 0xe6, 0xf7, 0xe1, 0x19, 0xb8,
                    0x3b, 0x66, 0xed, 0x6b, 0x9e, 0xc3, 0xd3, 0x25, 0x1e, 0x38, 0x6d, 0xfe, 0x87, 0xd2, 0xc6, 0xc7,
                },
                .pLen = 32,
                .qBytes = {
                    0xb7, 0x73, 0x38, 0x16, 0x02, 0xab, 0x55, 0x4a, 0x34, 0xea, 0xa2, 0xe6, 0x2a, 0x7a, 0x01, 0x88,
                    0x92, 0xfa, 0xa8, 0xbc, 0x14, 0xc3, 0x6f, 0x25, 0x66, 0x31, 0xd7, 0xe7, 0x83, 0xa6, 0x54, 0x77,
                },
                .qLen = 32
            }
        }
    },
};

#define NUM_PKCS1_V21_RND_TESTS 4
RndTestParams pkcs1V21RndParams[NUM_PKCS1_V21_RND_TESTS] =
{
    {
        .hashType = OS_CryptoDigest_ALG_MD5,
        .keyBits = 384,
        .hashBytes = 16
    },
    {
        .hashType = OS_CryptoDigest_ALG_MD5,
        .keyBits = 512,
        .hashBytes = 16
    },
    {
        .hashType = OS_CryptoDigest_ALG_MD5,
        .keyBits = 1024,
        .hashBytes = 16
    },
    {
        .hashType = OS_CryptoDigest_ALG_SHA256,
        .keyBits = 512,
        .hashBytes = 32
    },
};

// -----------------------------------------------------------------------------

static OS_CryptoKey_Data_t* testKeyDataList[] =
{
    &pkcs1V15Vectors[0].pubKey,
    &pkcs1V15Vectors[0].prvKey,
    &pkcs1V15Vectors[1].pubKey,
    &pkcs1V15Vectors[1].prvKey,
    &pkcs1V15Vectors[2].pubKey,
    &pkcs1V15Vectors[2].prvKey,
    &pkcs1V15Vectors[3].pubKey,
    &pkcs1V15Vectors[3].prvKey,
    &pkcs1V15Vectors[4].pubKey,
    &pkcs1V15Vectors[4].prvKey,
    &pkcs1V15Vectors[5].pubKey,
    &pkcs1V15Vectors[5].prvKey,
    &pkcs1V21Vectors[0].pubKey,
    &pkcs1V21Vectors[0].prvKey,
    &pkcs1V21Vectors[1].pubKey,
    &pkcs1V21Vectors[1].prvKey,
    &pkcs1V21Vectors[2].pubKey,
    &pkcs1V21Vectors[2].prvKey,
    &pkcs1V21Vectors[3].pubKey,
    &pkcs1V21Vectors[3].prvKey,
    NULL
};

// -----------------------------------------------------------------------------

static OS_Error_t
do_RSA_verify(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal,
    OS_CryptoKey_Handle_t  hPubKey,
    int                    sigType,
    int                    hashType,
    const ByteVector*      hash,
    const ByteVector*      sig)
{
    OS_Error_t err;
    OS_CryptoSignature_Handle_t hSig;

    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, NULL, hPubKey,
                                         sigType, hashType));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);

    if ((err = OS_CryptoSignature_verify(hSig, hash->bytes, hash->len,
                                         sig->bytes, sig->len)))
    {
        return err;
    }

    TEST_SUCCESS(OS_CryptoSignature_free(hSig));

    return OS_SUCCESS;
}

static void
test_OS_CryptoSignature_do_RSA_PKCS1_V15_verify(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    TestVector* vec;
    OS_CryptoKey_Handle_t hPubKey;

    TEST_START("i", mode, "i", keepLocal);

    for (size_t i = 0; i < NUM_PKCS1_V15_VECTORS; i++)
    {
        vec = &pkcs1V15Vectors[i];
        TEST_SUCCESS(OS_CryptoKey_import(&hPubKey, hCrypto, &vec->pubKey));
        TEST_SUCCESS(do_RSA_verify(hCrypto, mode, keepLocal, hPubKey,
                                   OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                   vec->hashType, &vec->hash, &vec->sig));
        TEST_SUCCESS(OS_CryptoKey_free(hPubKey));
    }

    TEST_FINISH();
}

static void
test_OS_CryptoSignature_do_RSA_PKCS1_V21_verify(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    TestVector* vec;
    OS_CryptoKey_Handle_t hPubKey;

    TEST_START("i", mode, "i", keepLocal);

    for (size_t i = 0; i < NUM_PKCS1_V21_VECTORS; i++)
    {
        vec = &pkcs1V21Vectors[i];
        TEST_SUCCESS(OS_CryptoKey_import(&hPubKey, hCrypto, &vec->pubKey));
        TEST_SUCCESS(do_RSA_verify(hCrypto, mode, keepLocal, hPubKey,
                                   OS_CryptoSignature_ALG_RSA_PKCS1_V21,
                                   vec->hashType, &vec->hash, &vec->sig));
        TEST_SUCCESS(OS_CryptoKey_free(hPubKey));
    }

    TEST_FINISH();
}

static OS_Error_t
do_RSA_sign(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal,
    OS_CryptoKey_Handle_t  hPrvKey,
    int                    sigType,
    int                    hashType,
    const ByteVector*      hash,
    const ByteVector*      sig)
{
    OS_Error_t err;
    OS_CryptoSignature_Handle_t hSig;
    uint8_t buf[512];
    size_t bufLen = sizeof(buf);

    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, hPrvKey, NULL,
                                         sigType, hashType));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);

    if ((err = OS_CryptoSignature_sign(hSig, hash->bytes, hash->len, buf,
                                       &bufLen)))
    {
        return err;
    }

    TEST_TRUE(!memcmp(sig->bytes, buf, bufLen));
    TEST_SUCCESS(OS_CryptoSignature_free(hSig));

    return OS_SUCCESS;
}

static void
test_OS_CryptoSignature_do_RSA_PKCS1_V15_sign(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    OS_CryptoKey_Handle_t hPrvKey;
    TestVector* vec;

    TEST_START("i", mode, "i", keepLocal);

    for (size_t i = 0; i < NUM_PKCS1_V15_VECTORS; i++)
    {
        vec = &pkcs1V15Vectors[i];
        TEST_SUCCESS(OS_CryptoKey_import(&hPrvKey, hCrypto, &vec->prvKey));
        TEST_SUCCESS(do_RSA_sign(hCrypto, mode, keepLocal, hPrvKey,
                                 OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                 vec->hashType, &vec->hash, &vec->sig));
        TEST_SUCCESS(OS_CryptoKey_free(hPrvKey));
    }

    TEST_FINISH();
}

static OS_Error_t
do_RSA_rnd(
    OS_Crypto_Handle_t       hCrypto,
    const OS_Crypto_Mode_t   mode,
    const bool               keepLocal,
    OS_CryptoSignature_Alg_t sigType,
    size_t                   keyBits,
    OS_CryptoDigest_Alg_t    hashType,
    size_t                   hashBytes)
{
    OS_Error_t err;
    OS_CryptoSignature_Handle_t hSig;
    OS_CryptoKey_Handle_t hPrvKey, hPubKey;
    uint8_t hash[256], sig[512];
    size_t sigLen = sizeof(sig);
    static OS_CryptoKey_Spec_t rsaSpec =
    {
        .type = OS_CryptoKey_SPECTYPE_BITS,
        .key.type = OS_CryptoKey_TYPE_RSA_PRV,
    };

    rsaSpec.key.params.bits = keyBits;
    rsaSpec.key.attribs.keepLocal = keepLocal;

    // Generate random key pair and hash
    TEST_SUCCESS(OS_CryptoKey_generate(&hPrvKey, hCrypto, &rsaSpec));
    TEST_SUCCESS(OS_CryptoKey_makePublic(&hPubKey, hCrypto, hPrvKey,
                                         &rsaSpec.key.attribs));
    TEST_SUCCESS(OS_CryptoRng_getBytes(hCrypto, 0, hash, hashBytes));

    // We use MD5 here as that fits with the sig size and key size for both
    // types of padding
    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, hPrvKey, hPubKey,
                                         sigType, hashType));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);

    // Sign
    TEST_SUCCESS(OS_CryptoSignature_sign(hSig, hash, hashBytes, sig, &sigLen));

    // Verify
    if ((err = OS_CryptoSignature_verify(hSig, hash, hashBytes, sig,
                                         sigLen)) != OS_SUCCESS)
    {
        return err;
    }

    TEST_SUCCESS(OS_CryptoSignature_free(hSig));
    TEST_SUCCESS(OS_CryptoKey_free(hPrvKey));
    TEST_SUCCESS(OS_CryptoKey_free(hPubKey));

    return OS_SUCCESS;
}

static void
test_OS_CryptoSignature_do_RSA_PKCS1_V15_rnd(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    TEST_START("i", mode, "i", keepLocal);

    for (size_t i = 0; i < NUM_PKCS1_V15_RND_TESTS; i++)
    {
        TEST_SUCCESS(do_RSA_rnd(hCrypto, mode, keepLocal,
                                OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                pkcs1V15RndParams[i].keyBits,
                                pkcs1V15RndParams[i].hashType,
                                pkcs1V15RndParams[i].hashBytes));
    }

    TEST_FINISH();
}

static void
test_OS_CryptoSignature_do_RSA_PKCS1_V21_rnd(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    TEST_START("i", mode, "i", keepLocal);

    for (size_t i = 0; i < NUM_PKCS1_V21_RND_TESTS; i++)
    {
        TEST_SUCCESS(do_RSA_rnd(hCrypto, mode, keepLocal,
                                OS_CryptoSignature_ALG_RSA_PKCS1_V21,
                                pkcs1V21RndParams[i].keyBits,
                                pkcs1V21RndParams[i].hashType,
                                pkcs1V21RndParams[i].hashBytes));
    }

    TEST_FINISH();
}

static void
test_OS_CryptoSignature_sign_neg(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    OS_CryptoKey_Handle_t hPrvKey, hPubKey;
    OS_CryptoSignature_Handle_t hSig;
    char signature[256], msgData[] = "test";
    size_t signatureSize = sizeof(signature);

    TEST_START("i", mode, "i", keepLocal);

    TEST_SUCCESS(OS_CryptoKey_import(&hPrvKey, hCrypto, &rsa1024PrvData));
    TEST_SUCCESS(OS_CryptoKey_import(&hPubKey, hCrypto, &rsa1024PubData));

    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, hPrvKey, NULL,
                                         OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                         OS_CryptoDigest_ALG_NONE));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);

    // Use signature handle
    TEST_INVAL_PARAM(OS_CryptoSignature_sign(NULL, msgData, strlen(msgData),
                                             signature, &signatureSize));

    // Use empty data
    TEST_INVAL_PARAM(OS_CryptoSignature_sign(hSig, NULL, strlen(msgData),
                                             signature, &signatureSize));

    // Use zero length data
    TEST_INVAL_PARAM(OS_CryptoSignature_sign(hSig, msgData, 0, signature,
                                             &signatureSize));

    // Use NULL output buffer
    TEST_INVAL_PARAM(OS_CryptoSignature_sign(hSig, msgData, strlen(msgData),
                                             NULL, &signatureSize));

    // Use NULL output size buffer
    TEST_INVAL_PARAM(OS_CryptoSignature_sign(hSig, msgData, strlen(msgData),
                                             signature, NULL));

    // Use too small output buffer
    signatureSize = 10;
    TEST_TOO_SMALL(OS_CryptoSignature_sign(hSig, msgData, strlen(msgData),
                                           signature, &signatureSize));
    TEST_TRUE(signatureSize == (rsa1024PrvData.data.rsa.prv.pLen +
                                rsa1024PrvData.data.rsa.prv.qLen));

    TEST_SUCCESS(OS_CryptoSignature_free(hSig));

    // Try signing with only a public key
    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, NULL, hPubKey,
                                         OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                         OS_CryptoDigest_ALG_NONE));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);
    TEST_ABORTED(OS_CryptoSignature_sign(hSig, msgData, strlen(msgData),
                                         signature, &signatureSize));

    TEST_SUCCESS(OS_CryptoSignature_free(hSig));
    TEST_SUCCESS(OS_CryptoKey_free(hPrvKey));
    TEST_SUCCESS(OS_CryptoKey_free(hPubKey));

    TEST_FINISH();
}

static void
test_OS_CryptoSignature_verify_neg(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    OS_CryptoKey_Handle_t hPubKey, hPrvKey;
    OS_CryptoSignature_Handle_t hSig;
    char msgData[] = "test";
    uint8_t sig[1024];

    TEST_START("i", mode, "i", keepLocal);

    TEST_SUCCESS(OS_CryptoKey_import(&hPrvKey, hCrypto, &rsa1024PrvData));
    TEST_SUCCESS(OS_CryptoKey_import(&hPubKey, hCrypto, &rsa1024PubData));
    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, NULL, hPubKey,
                                         OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                         OS_CryptoDigest_ALG_NONE));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);

    // Use signature handle
    TEST_INVAL_PARAM(OS_CryptoSignature_verify(NULL, msgData, strlen(msgData),
                                               sig, sizeof(sig)));

    // Use empty msg buffer
    TEST_INVAL_PARAM(OS_CryptoSignature_verify(hSig, NULL, strlen(msgData),
                                               sig, sizeof(sig)));

    // Use zero lenght input
    TEST_INVAL_PARAM(OS_CryptoSignature_verify(hSig, msgData, 0, sig,
                                               sizeof(sig)));

    // Use empty signature buffer
    TEST_INVAL_PARAM(OS_CryptoSignature_verify(hSig, msgData, strlen(msgData),
                                               NULL, sizeof(sig)));

    // Use zero length signature
    TEST_INVAL_PARAM(OS_CryptoSignature_verify(hSig, msgData, strlen(msgData),
                                               sig, 0));

    TEST_SUCCESS(OS_CryptoSignature_free(hSig));

    // Try verification if we have only private key
    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, hPrvKey, NULL,
                                         OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                         OS_CryptoDigest_ALG_NONE));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);
    TEST_ABORTED(OS_CryptoSignature_verify(hSig, msgData, strlen(msgData), sig,
                                           sizeof(sig)));
    TEST_SUCCESS(OS_CryptoSignature_free(hSig));

    TEST_SUCCESS(OS_CryptoKey_free(hPubKey));
    TEST_SUCCESS(OS_CryptoKey_free(hPrvKey));

    TEST_FINISH();
}

static void
test_OS_CryptoSignature_init_pos(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    OS_CryptoKey_Handle_t hPubKey, hPrvKey;
    OS_CryptoSignature_Handle_t hSig;

    TEST_START("i", mode, "i", keepLocal);

    TEST_SUCCESS(OS_CryptoKey_import(&hPrvKey, hCrypto, &rsa1024PrvData));
    TEST_SUCCESS(OS_CryptoKey_import(&hPubKey, hCrypto, &rsa1024PubData));

    // Init just with prv key
    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, hPrvKey, NULL,
                                         OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                         OS_CryptoDigest_ALG_NONE));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);
    TEST_SUCCESS(OS_CryptoSignature_free(hSig));

    // Init just with pub key
    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, NULL, hPubKey,
                                         OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                         OS_CryptoDigest_ALG_NONE));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);
    TEST_SUCCESS(OS_CryptoSignature_free(hSig));

    // Use both keys
    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, hPrvKey, hPubKey,
                                         OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                         OS_CryptoDigest_ALG_NONE));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);
    TEST_SUCCESS(OS_CryptoSignature_free(hSig));

    TEST_SUCCESS(OS_CryptoKey_free(hPubKey));
    TEST_SUCCESS(OS_CryptoKey_free(hPrvKey));

    TEST_FINISH();
}

static void
test_OS_CryptoSignature_init_neg(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    OS_CryptoKey_Handle_t hPubKey, hPrvKey;
    OS_CryptoSignature_Handle_t hSig;

    TEST_START("i", mode, "i", keepLocal);

    TEST_SUCCESS(OS_CryptoKey_generate(&hPubKey, hCrypto, &aes128Spec));
    TEST_SUCCESS(OS_CryptoKey_import(&hPrvKey, hCrypto, &rsa1024PrvData));

    // Use empty signature handle
    TEST_INVAL_PARAM(OS_CryptoSignature_init(NULL, hCrypto, hPrvKey, NULL,
                                             OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                             OS_CryptoDigest_ALG_NONE));

    // Use empty crypto handle
    TEST_INVAL_PARAM(OS_CryptoSignature_init(&hSig, NULL, hPrvKey, NULL,
                                             OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                             OS_CryptoDigest_ALG_NONE));

    // Use empty key handles
    TEST_INVAL_PARAM(OS_CryptoSignature_init(&hSig, hCrypto, NULL, NULL,
                                             OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                             OS_CryptoDigest_ALG_NONE));

    // Use wrong type of key for prv
    TEST_INVAL_PARAM(OS_CryptoSignature_init(&hSig, hCrypto, hPubKey, NULL,
                                             OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                             OS_CryptoDigest_ALG_NONE));

    // Use wrong type of key for prv
    TEST_INVAL_PARAM(OS_CryptoSignature_init(&hSig, hCrypto, NULL, hPubKey,
                                             OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                             OS_CryptoDigest_ALG_NONE));

    // Use wrong algorithm
    TEST_NOT_SUPP(OS_CryptoSignature_init(&hSig, hCrypto, hPrvKey, NULL, 666,
                                          OS_CryptoDigest_ALG_NONE));

    // Use wrong digest algorithm
    TEST_NOT_SUPP(OS_CryptoSignature_init(&hSig, hCrypto, hPrvKey, NULL,
                                          OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                          666));

    TEST_SUCCESS(OS_CryptoKey_free(hPubKey));
    TEST_SUCCESS(OS_CryptoKey_free(hPrvKey));

    TEST_FINISH();
}

static void
test_OS_CryptoSignature_free_pos(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    OS_CryptoKey_Handle_t hPubKey;
    OS_CryptoSignature_Handle_t hSig;

    TEST_START("i", mode, "i", keepLocal);

    TEST_SUCCESS(OS_CryptoKey_import(&hPubKey, hCrypto, &rsa1024PubData));
    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, NULL, hPubKey,
                                         OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                         OS_CryptoDigest_ALG_NONE));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);

    TEST_SUCCESS(OS_CryptoSignature_free(hSig));

    TEST_SUCCESS(OS_CryptoKey_free(hPubKey));

    TEST_FINISH();
}

static void
test_OS_CryptoSignature_free_neg(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    OS_CryptoKey_Handle_t hPubKey;
    OS_CryptoSignature_Handle_t hSig;

    TEST_START("i", mode, "i", keepLocal);

    TEST_SUCCESS(OS_CryptoKey_import(&hPubKey, hCrypto, &rsa1024PubData));
    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, NULL, hPubKey,
                                         OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                         OS_CryptoDigest_ALG_NONE));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);

    // Empty sig handle
    TEST_INVAL_PARAM(OS_CryptoSignature_free(NULL));

    TEST_SUCCESS(OS_CryptoSignature_free(hSig));
    TEST_SUCCESS(OS_CryptoKey_free(hPubKey));

    TEST_FINISH();
}

static void
test_OS_CryptoSignature_sign_dataport(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    OS_CryptoKey_Handle_t hPrvKey;
    OS_CryptoSignature_Handle_t hSig;
    static unsigned int hashBuf[OS_DATAPORT_DEFAULT_SIZE + 1],
           sigBuf[OS_DATAPORT_DEFAULT_SIZE + 1];
    size_t hashLen, sigLen;

    TEST_START("i", mode, "i", keepLocal);

    TEST_SUCCESS(OS_CryptoKey_import(&hPrvKey, hCrypto, &rsa1024PrvData));
    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, hPrvKey, NULL,
                                         OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                         OS_CryptoDigest_ALG_NONE));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);

    // Should go through but then return ABORTED because crypto fails
    hashLen = OS_DATAPORT_DEFAULT_SIZE;
    sigLen = OS_DATAPORT_DEFAULT_SIZE;
    TEST_ABORTED(OS_CryptoSignature_sign(hSig, hashBuf, hashLen, sigBuf,
                                         &sigLen));

    // Should fail because input is too long
    hashLen = OS_DATAPORT_DEFAULT_SIZE + 1;
    sigLen = OS_DATAPORT_DEFAULT_SIZE;
    TEST_INVAL_PARAM(OS_CryptoSignature_sign(hSig, hashBuf, hashLen, sigBuf,
                                             &sigLen));

    // Should fail because output is too long
    hashLen = OS_DATAPORT_DEFAULT_SIZE;
    sigLen = OS_DATAPORT_DEFAULT_SIZE + 1;
    TEST_INVAL_PARAM(OS_CryptoSignature_sign(hSig, hashBuf, hashLen, sigBuf,
                                             &sigLen));

    TEST_SUCCESS(OS_CryptoSignature_free(hSig));
    TEST_SUCCESS(OS_CryptoKey_free(hPrvKey));

    TEST_FINISH();
}

static void
test_OS_CryptoSignature_sign_buffer(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    OS_CryptoKey_Handle_t hPrvKey;
    OS_CryptoSignature_Handle_t hSig;
    static unsigned int hashBuf[OS_DATAPORT_DEFAULT_SIZE + 1];
    size_t hashLen, sigLen;

    TEST_START("i", mode, "i", keepLocal);

    TEST_SUCCESS(OS_CryptoKey_import(&hPrvKey, hCrypto,
                                     &pkcs1V15Vectors[0].prvKey));
    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, hPrvKey, NULL,
                                         OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                         pkcs1V15Vectors[0].hashType));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);

    // Let input/output buffer be the same; this should work, as long as we
    // are below the DATAPORT size (which is the size internally used to
    // have a buffer where a copy of the input is kept).
    hashLen = pkcs1V15Vectors[0].hash.len;
    sigLen = OS_DATAPORT_DEFAULT_SIZE;
    memcpy(hashBuf, pkcs1V15Vectors[0].hash.bytes, hashLen);
    TEST_SUCCESS(OS_CryptoSignature_sign(hSig, hashBuf, hashLen, hashBuf, &sigLen));
    TEST_TRUE(sigLen == pkcs1V15Vectors[0].sig.len);
    TEST_TRUE(!memcmp(hashBuf, pkcs1V15Vectors[0].sig.bytes, sigLen));

    // This should fail as input is too big for internal buffer; which is set
    // to the size of the dataport.
    hashLen = OS_DATAPORT_DEFAULT_SIZE + 1;
    sigLen = OS_DATAPORT_DEFAULT_SIZE;
    TEST_INVAL_PARAM(OS_CryptoSignature_sign(hSig, hashBuf, hashLen, hashBuf,
                                             &sigLen));

    TEST_SUCCESS(OS_CryptoSignature_free(hSig));
    TEST_SUCCESS(OS_CryptoKey_free(hPrvKey));

    TEST_FINISH();
}

static void
test_OS_CryptoSignature_verify_dataport(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    OS_CryptoKey_Handle_t hPubKey;
    OS_CryptoSignature_Handle_t hSig;
    static unsigned int hashBuf[OS_DATAPORT_DEFAULT_SIZE + 1],
           sigBuf[OS_DATAPORT_DEFAULT_SIZE + 1];
    size_t hashLen, sigLen;

    TEST_START("i", mode, "i", keepLocal);

    TEST_SUCCESS(OS_CryptoKey_import(&hPubKey, hCrypto, &rsa1024PubData));
    TEST_SUCCESS(OS_CryptoSignature_init(&hSig, hCrypto, NULL, hPubKey,
                                         OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                         OS_CryptoDigest_ALG_NONE));
    TEST_LOCACTION_FLAG(mode, keepLocal, hSig);

    // Should go through but fail with ABORTED because crypto fails
    sigLen = (rsa1024PrvData.data.rsa.prv.pLen + rsa1024PrvData.data.rsa.prv.qLen);
    hashLen = OS_DATAPORT_DEFAULT_SIZE - sigLen;
    TEST_ABORTED(OS_CryptoSignature_verify(hSig, hashBuf, hashLen, sigBuf,
                                           sigLen));

    // Should fail because the total of both is too big for the dataport
    hashLen = 16;
    sigLen = OS_DATAPORT_DEFAULT_SIZE;
    TEST_INVAL_PARAM(OS_CryptoSignature_verify(hSig, hashBuf, hashLen, sigBuf,
                                               sigLen));

    TEST_SUCCESS(OS_CryptoSignature_free(hSig));
    TEST_SUCCESS(OS_CryptoKey_free(hPubKey));

    TEST_FINISH();
}

static void
test_OS_CryptoSignature_key_neg(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode,
    const bool             keepLocal)
{
    OS_CryptoKey_Handle_t hPubKey, hPrvKey;
    OS_CryptoSignature_Handle_t hSig;

    TEST_START("i", mode, "i", keepLocal);

    // Test with both keys having different locality attributes
    rsa1024PrvData.attribs.keepLocal = false;
    rsa1024PubData.attribs.keepLocal = true;

    TEST_SUCCESS(OS_CryptoKey_import(&hPrvKey, hCrypto, &rsa1024PrvData));
    TEST_LOCACTION_FLAG(mode, false, hPrvKey);
    TEST_SUCCESS(OS_CryptoKey_import(&hPubKey, hCrypto, &rsa1024PubData));
    TEST_LOCACTION_FLAG(mode, true, hPubKey);

    // Should fail due to different key localities
    TEST_INVAL_PARAM(OS_CryptoSignature_init(&hSig, hCrypto, hPrvKey, hPubKey,
                                             OS_CryptoSignature_ALG_RSA_PKCS1_V15,
                                             OS_CryptoDigest_ALG_NONE));

    TEST_SUCCESS(OS_CryptoKey_free(hPubKey));
    TEST_SUCCESS(OS_CryptoKey_free(hPrvKey));

    TEST_FINISH();
}

void
test_OS_CryptoSignature(
    OS_Crypto_Handle_t     hCrypto,
    const OS_Crypto_Mode_t mode)
{
    keyData_setLocality(keyDataList, true);
    keySpec_setLocality(keySpecList, true);

    test_OS_CryptoSignature_init_pos(hCrypto, mode, true);
    test_OS_CryptoSignature_init_neg(hCrypto, mode, true);

    test_OS_CryptoSignature_free_pos(hCrypto, mode, true);
    test_OS_CryptoSignature_free_neg(hCrypto, mode, true);

    // Test only failures separately, as computing ref. values is sufficient
    // proof of correct funtioning
    test_OS_CryptoSignature_sign_neg(hCrypto, mode, true);
    test_OS_CryptoSignature_verify_neg(hCrypto, mode, true);

    // Test vectors
    test_OS_CryptoSignature_do_RSA_PKCS1_V15_sign(hCrypto, mode, true);
    test_OS_CryptoSignature_do_RSA_PKCS1_V15_verify(hCrypto, mode, true);
    // We cannot do fixed test vectors for PKCS#1 V2.1 because the resulting
    // signatures are probablistic and we currently do not support providing
    // a fixed value as randomness during signing
    test_OS_CryptoSignature_do_RSA_PKCS1_V21_verify(hCrypto, mode, true);

    // Generate random vectors and sign/verify with them
    test_OS_CryptoSignature_do_RSA_PKCS1_V15_rnd(hCrypto, mode, true);
    test_OS_CryptoSignature_do_RSA_PKCS1_V21_rnd(hCrypto, mode, true);

    switch (mode)
    {
    case OS_Crypto_MODE_LIBRARY:
        test_OS_CryptoSignature_sign_buffer(hCrypto, mode, true);
        break;
    case OS_Crypto_MODE_CLIENT:
        test_OS_CryptoSignature_sign_dataport(hCrypto, mode, true);
        test_OS_CryptoSignature_verify_dataport(hCrypto, mode, true);
        break;
    case OS_Crypto_MODE_KEY_SWITCH:
        keyData_setLocality(keyDataList, false);
        keyData_setLocality(testKeyDataList, false);
        keySpec_setLocality(keySpecList, false);
        test_OS_CryptoSignature_do_RSA_PKCS1_V15_sign(hCrypto, mode, false);
        test_OS_CryptoSignature_do_RSA_PKCS1_V15_verify(hCrypto, mode, false);
        test_OS_CryptoSignature_do_RSA_PKCS1_V21_verify(hCrypto, mode, false);
        test_OS_CryptoSignature_do_RSA_PKCS1_V15_rnd(hCrypto, mode, false);
        test_OS_CryptoSignature_do_RSA_PKCS1_V21_rnd(hCrypto, mode, false);
        test_OS_CryptoSignature_key_neg(hCrypto, mode, false);
        break;
    default:
        break;
    }
}